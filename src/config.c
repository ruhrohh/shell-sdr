/**
 * @file config.c
 * @brief Configuration file handling
 *
 * Manages the shell's configuration file (.myshell_config) in the user's
 * home directory. Handles loading and saving aliases, creating default
 * configurations.
 */

#include "shell.h"

// Configuration file path (in user's home directory)
#define CONFIG_FILE_NAME ".myshell_config"

// Get path to config file
char* get_config_file_path() {
    char* home_dir = getenv("HOME");
    if (!home_dir) {
        fprintf(stderr, "Could not determine home directory\n");
        return NULL;
    }

    char* config_path = malloc(strlen(home_dir) + strlen(CONFIG_FILE_NAME) + 2); // +2 for / and null terminator
    if (!config_path) {
        perror("malloc error");
        return NULL;
    }

    sprintf(config_path, "%s/%s", home_dir, CONFIG_FILE_NAME);
    return config_path;
}

// Check if an alias already exists
int alias_exists(const char* name) {
    for (int i = 0; i < alias_count; i++) {
        if (strcmp(aliases[i].name, name) == 0) {
            return 1; // Alias exists
        }
    }
    return 0; // Alias doesn't exist
}

// Initialize the config file
int initialize_config_file() {
    char* config_path = get_config_file_path();
    if (!config_path) {
        return 0;
    }

    // Check if file already exists
    FILE* test_file = fopen(config_path, "r");
    if (test_file) {
        // File exists, nothing to do
        fclose(test_file);
        free(config_path);
        return 1;
    }

    // Create the file with default header
    FILE* config_file = fopen(config_path, "w");
    if (!config_file) {
        // Can't create file, might be a permissions issue
        fprintf(stderr, "Warning: Could not create config file at %s\n", config_path);
        free(config_path);
        return 0;
    }

    // Write default header
    fprintf(config_file, "# MyShell Configuration File\n");
    fprintf(config_file, "# This file is automatically generated and updated\n\n");

    // Write default aliases section
    fprintf(config_file, "# Aliases\n");
    fprintf(config_file, "alias ls='ls --color=auto'\n");

    // Close file
    fclose(config_file);
    printf("Created new config file at %s\n", config_path);

    free(config_path);
    return 1;
}

// Load aliases from config file
int load_aliases_from_config() {
    char* config_path = get_config_file_path();
    if (!config_path) {
        return 0;
    }

    FILE* config_file = fopen(config_path, "r");
    if (!config_file) {
        // It's okay if the file doesn't exist yet
        free(config_path);
        return 1;
    }

    char line[MAX_COMMAND_LENGTH];
    while (fgets(line, sizeof(line), config_file)) {
        // Remove newline
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
        }

        // Skip empty lines and comments
        if (line[0] == '\0' || line[0] == '#') {
            continue;
        }

        // Check if line starts with "alias "
        if (strncmp(line, "alias ", 6) == 0) {
            // We have an alias definition
            char* alias_def = line + 6; // Skip "alias " prefix

            // Look for the first '=' character
            char* equals = strchr(alias_def, '=');
            if (!equals) {
                continue; // Invalid format, skip line
            }

            // Split the string at '='
            *equals = '\0';
            char* name = alias_def;
            char* value = equals + 1;

            // Remove quotes from value if present
            if (value[0] == '\'' || value[0] == '"') {
                value++;

                // Find the closing quote
                char* end = value + strlen(value) - 1;
                if (*end == '\'' || *end == '"') {
                    *end = '\0';
                }
            }

            // Check if this alias already exists
            int exists = 0;
            for (int i = 0; i < alias_count; i++) {
                if (strcmp(aliases[i].name, name) == 0) {
                    // Update existing alias
                    free(aliases[i].value);
                    aliases[i].value = strdup(value);
                    exists = 1;
                    break;
                }
            }

            // Add alias to the list if it doesn't exist
            if (!exists && alias_count < MAX_ALIASES) {
                aliases[alias_count].name = strdup(name);
                aliases[alias_count].value = strdup(value);
                alias_count++;
            } else if (!exists) {
                fprintf(stderr, "Maximum number of aliases reached\n");
                break;
            }
        }
    }

    fclose(config_file);
    free(config_path);
    return 1;
}

// Save aliases to config file
int save_aliases_to_config() {
    char* config_path = get_config_file_path();
    if (!config_path) {
        return 0;
    }

    FILE* config_file = fopen(config_path, "w");
    if (!config_file) {
        perror("Error opening config file for writing");
        free(config_path);
        return 0;
    }

    // Write header
    fprintf(config_file, "# MyShell Configuration File\n");
    fprintf(config_file, "# This file is automatically generated and updated\n\n");

    // Write aliases section
    fprintf(config_file, "# Aliases\n");
    for (int i = 0; i < alias_count; i++) {
        fprintf(config_file, "alias %s='%s'\n", aliases[i].name, aliases[i].value);
    }

    // Future config sections can be added here

    fclose(config_file);
    free(config_path);
    return 1;
}